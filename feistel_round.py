"""
Author: Aaron Huang
Last Modified: 10/14/2024
Description:
    Implementation of DES Feistel Rounds in Python

    What is a Feistel Round:
        1) Takes an input of 64 bits. Splits the Input Data into Left and Right Halves of 32 bits. 
        2) Expands the Right Half to 48 bits using the E-box.
        3) Mixes the Expanded Right Half with the Round Key by XORing the 48-bit expanded right half 
        with the 48-bit round key generated by the key scheduling algorithm.
        4) Substitutes using S-boxes, returning a 32 bit string.
        5) Permutes with P-box, giving us the diffused 32 bit string.
        6) XOR the diffused 32 bit string with the old left half to obtain the final 32 bit string.
        7) Finally, the old right half of 32 bits becomes the new left half
        and the final 32 bit string from the permutation becomes the new right half.

"""

from confusion import confusion

p_box = [
    16, 7, 20, 21,
    29, 12, 28, 17,
    1, 15, 23, 26,
    5, 18, 31, 10,
    2, 8, 24, 14,
    32, 27, 3, 9,
    19, 13, 30, 6,
    22, 11, 4, 25,
]

s_box = [
        #S1
        [
            [14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7],
            [0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8],
            [4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7, 3, 10, 5, 0],
            [15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13]
        ],

        #S2
        [
            [15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10],
            [3, 13, 4, 7, 15, 2, 8, 14, 12, 0, 1, 10, 6, 9, 11, 5],
            [0, 14, 7, 11, 10, 4, 13, 1, 5, 8, 12, 6, 9, 3, 2, 15],
            [13, 8, 10, 1, 3, 15, 4, 2, 11, 6, 7, 12, 0, 5, 14, 9],
        ],

        #S3
        [
            [10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8],
            [13, 7, 0, 9, 3, 4, 6, 10, 2, 8, 5, 14, 12, 11, 15, 1],
            [13, 6, 4, 9, 8, 15, 3, 0, 11, 1, 2, 12, 5, 10, 14, 7],
            [1, 10, 13, 0, 6, 9, 8, 7, 4, 15, 14, 3, 11, 5, 2, 12],
        ],

        #S4
        [
            [7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15],
            [13, 8, 11, 5, 6, 15, 0, 3, 4, 7, 2, 12, 1, 10, 14, 9],
            [10, 6, 9, 0, 12, 11, 7, 13, 15, 1, 3, 14, 5, 2, 8, 4],
            [3, 15, 0, 6, 10, 1, 13, 8, 9, 4, 5, 11, 12, 7, 2, 14],
        ],

        #S5
        [
            [2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9],
            [14, 11, 2, 12, 4, 7, 13, 1, 5, 0, 15, 10, 3, 9, 8, 6],
            [4, 2, 1, 11, 10, 13, 7, 8, 15, 9, 12, 5, 6, 3, 0, 14],
            [11, 8, 12, 7, 1, 14, 2, 13, 6, 15, 0, 9, 10, 4, 5, 3],
        ],

        #S6
        [
            [12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11],
            [10, 15, 4, 2, 7, 12, 9, 5, 6, 1, 13, 14, 0, 11, 3, 8],
            [9, 14, 15, 5, 2, 8, 12, 3, 7, 0, 4, 10, 1, 13, 11, 6],
            [4, 3, 2, 12, 9, 5, 15, 10, 11, 14, 1, 7, 6, 0, 8, 13],
        ],

        #S7
        [
            [4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1],
            [13, 0, 11, 7, 4, 9, 1, 10, 14, 3, 5, 12, 2, 15, 8, 6],
            [1, 4, 11, 13, 12, 3, 7, 14, 10, 15, 6, 8, 0, 5, 9, 2],
            [6, 11, 13, 8, 1, 4, 10, 7, 9, 5, 0, 15, 14, 2, 3, 12],
        ],

        #S8
        [
            [13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7],
            [1, 15, 13, 8, 10, 3, 7, 4, 12, 5, 6, 11, 0, 14, 9, 2],
            [7, 11, 4, 1, 9, 12, 14, 2, 0, 6, 10, 13, 15, 3, 5, 8],
            [2, 1, 14, 7, 4, 10, 8, 13, 15, 12, 9, 0, 3, 5, 6, 11],
        ]
    ]

e_box_table = [
        32, 1, 2, 3, 4, 5,
        4, 5, 6, 7, 8, 9,
        8, 9, 10, 11, 12, 13,
        12, 13, 14, 15, 16, 17,
        16, 17, 18, 19, 20, 21,
        20, 21, 22, 23, 24, 25,
        24, 25, 26, 27, 28, 29,
        28, 29, 30, 31, 32, 1
    ]

def permute(data: int, table: list, bit_length: int) -> int:
    """
    General permutation function that applies the given permutation table to the data.
    
    Args:
        data: The input data to permute (int).
        table: The permutation table (list of bit positions).
        bit_length: The number of bits in the output (e.g., 48 for PC-2, 32 for P-box).
    
    Returns:
        The permuted data (int).
    """
    permuted_data = 0
    for i, pos in enumerate(table):
        permuted_data |= ((data >> (bit_length - pos)) & 1) << (len(table) - 1 - i)
    return permuted_data

pc1_table = [
        57, 49, 41, 33, 25, 17, 9,
        1, 58, 50, 42, 34, 26, 18,
        10, 2, 59, 51, 43, 35, 27,
        19, 11, 3, 60, 52, 44, 36,
        63, 55, 47, 39, 31, 23, 15,
        7, 62, 54, 46, 38, 30, 22,
        14, 6, 61, 53, 45, 37, 29,
        21, 13, 5, 28, 20, 12, 4
    ]

pc2_table = [
        14, 17, 11, 24, 1, 5,
        3, 28, 15, 6, 21, 10,
        23, 19, 12, 4, 26, 8,
        16, 7, 27, 20, 13, 2,
        41, 52, 31, 37, 47, 55,
        30, 40, 51, 45, 33, 48,
        44, 49, 39, 56, 34, 53,
        46, 42, 50, 36, 29, 32
    ]

def key_schedule(des_key_64_bits: int) -> list[int]:
    """
    Takes a 64-bit DES key as input and returns a list of 16 round keys, each 48 bits long.
    """
    # Permuted Choice 1 (PC-1)
    permuted_key = permute(des_key_64_bits, pc1_table, 64)
    
    # Split the key into two 28-bit halves
    left_half = permuted_key >> 28          # 28-bit left half
    right_half = permuted_key & 0x0000000fffffff     # 28-bit right half
    
    round_keys = []     # will be returned in the end
    shift_schedule = [1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1] # pre-determined shifting of keys
    
    for round_num in range(16):
        # Apply left shifts according to the shift schedule
        left_half = (left_half << shift_schedule[round_num] & 0xfffffff) | (left_half >> (28 - shift_schedule[round_num]))
        right_half = (right_half << shift_schedule[round_num] & 0xfffffff) | (right_half >> (28 - shift_schedule[round_num]))
        
        # Combine the halves and apply Permuted Choice 2 (PC-2)
        combined_key = (left_half << 28) | (right_half) 
        round_key = permute(combined_key, pc2_table, 56)
        round_keys.append(hex(round_key))
    
    return round_keys

def feistel_round(input_data):
    # Step 1
    left_half = input_data >> 32          # 32-bit left half
    right_half = input_data & 0x00000000ffffffff    # 32-bit right half

    # Step 2: expand
    expanded_right = permute(right_half, e_box_table, 32)

    # Step 3: create the keys using the key_schedule function
    round_keys = key_schedule(input_data)

    # Step 3 (continued): mixing the expanded right with the keys
    xored_right = expanded_right ^ int(round_keys[0], 16)

    # Step 4, 5: confusion and diffusion
    substituted_data = confusion(xored_right, s_box)
    permuted_data = permute(substituted_data, p_box, 32)

    # Step 6: XOR old left half with permuted data
    new_right = left_half ^ permuted_data

    # Step 7: join the new right with new left to get the next 64 bit input
    new_input_data = (right_half << 32) | (new_right)

    return new_input_data

# test
input_data = 0xffffffffffffffff
for _ in range(10):
    input_data = feistel_round(input_data)
    print(bin(input_data))
    







    

